# <center>内存淘汰策略</center>

## Introduction

因为 Redis 是内存的缓存数据库，那么很自然的会联想到一个问题，就是内存的淘汰策略。因为 Redis 的内存是有限的，所以当内存不够的时候，就需要淘汰一些数据，从而释放内存。


### 内存淘汰策略

其实可以用决策树来记忆内存淘汰策略：

- 是否进行数据的淘汰?

    - Case 1 : 不淘汰 -> 我们选择直接抛出异常，停止进行运作即可
    - Case 2 : 进行内存淘汰

        - Case 2.1 : 对所有数据中进行淘汰:
            - Case 1 : `allkeys-random` : 随机淘汰任意的键值对
            - Case 2 : `allkeys-lru` : 最近最少使用的键值对进行淘汰
            - Case 3 : `allkeys-lfu` : 最少使用的键值对进行淘汰
        - Case 2.2 : 对过期的数据进行淘汰
            - Case 1 : `volatile-random` : 随机淘汰过期的键值对
            - Case 2 : `volatile-lru` : 最近最少使用的过期键值对进行淘汰
            - Case 3 : `volatile-lfu` : 最少使用的过期键值对进行淘汰
            - Case 4 : `volatile-ttl` : 淘汰剩余时间最少的键值对

其实就很明朗了，我们可以根据自己的需求进行设置对应的内存淘汰策略。


## 八股
### Q1 你了解 Redis 的过期策略和内存淘汰策略的区别吗？

首先，其实我们看名字都能知道他们的针对的情况是不同的。

- **内存淘汰 :** 其实很大程度上是指当内存满了的时候，redis会采取内存淘汰策略，来淘汰一些不必要的内存资源，以腾出空间，来保存新的内容。

- **过期键 :** 将已经过期的键值对进行删除，Redis采取了惰性删除+定期删除。

    - 什么是**惰性删除**呢？就是当我们去访问某个键值对的时候，会先判断这个键值对是否过期，如果过期了，那么就会进行删除操作。

    - 什么是 **定期删除** 呢？其实就是定期删除的文件是 **expire.c** 文件下的`activeExpireCycle`函数，它会每隔一段时间进行一次过期键的删除操作。就是选择随机找20个键值对进行定期检查是否过期，如果 抽样调查发现小于**25%** 就可以停止了。否则会一直进行定期删除。 

    ```c
    do {
        // 已经过期的数量
        int expired = 0;
        // 随机抽样调查的数量
        int num = 20;
        while(num -- ){
            // 从字典中随机找到一个键值对进行检查
            // 判断是否过期，如果过期了，就会进行删除操作
            if(isExpired(key)){
                dbDelete(db,key);
                expired ++;
            }
        }

        if(timelimit_exit) 
            return ;
    }while(expired > 20/4);
    ```

#### 惰性删除的实现:

```c
int expireIfNeeded(redisDb *db,robj *key){
    //判断 是否键值对过期
    if(!keyIsExpired(key)) return 0;

    //删除键值对

    // 如果 server.lazyfree_lazy_expire 为真，那么就会将键值对放入到懒惰删除的链表中

    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);
}
```

#### 为什么选择惰性删除和定期删除呢？

因为如果缓存中有很大一部分的键值对已经失效了/过期了，那么如果我们进行一次性的进行删除，那么其实会将接下来的 `Redis` 的命令进行阻塞住，也就是会占用主线程的时间，从而影响了 `Redis` 的性能。所以我们选择了惰性删除和定期删除的方式来进行删除操作。在需要的时候才会进行删除操作，从而提高了 `Redis` 的性能。因为如果就算真的过期了，如果没有影响到我们的操作，那么就没有必要进行删除操作。

### Q2 可以介绍一下 Redis 的淘汰策略吗？
见 Redis 的另一篇文章 