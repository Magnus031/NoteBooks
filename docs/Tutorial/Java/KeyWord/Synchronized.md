# <center>Synchronized</center>

## 1 介绍

## 2 作用


## 3A 实现原理

`Synchronized` 的实现原理本质上就是利用 互斥锁来进行实现的，也就是说在同一时间只允许一个线程来访问这个被锁住的共享资源。

但是这个共享资源是有多种的，比如说 `方法`，`代码块`，`静态方法`，`对象`等等。

往 `JVM` 的层面来看，其实就是每个 `Java` 对象都有一个 `monitor` 监视器锁，当一个线程进入了`Synchronized` 代码段的时候:

- 该线程会尝试的获取 Monitor
- Monitor 只允许一个线程的进入，其他线程就会被阻塞住(互斥锁)
- 退出同步块之后，就会释放 `Monitor` 其他线程就可以继续的抢占

### 3B 同步锁的优化
因为我们看上面的实现原理，其实很容易的就发现，`Synchronized` 的实现原理是基于互斥锁的，但是互斥锁是有一定的性能问题的，因为它会导致线程的阻塞，而且会导致线程的上下文切换，这样就会导致线程的性能下降。

所以自从 `JDK1.6` 之后，就引入了一些锁的优化机制，在不同的情况下会选择不同的锁来进行线程安全的保护。

<span style = "color:red">也就是说其实同步锁优化的梯度就是根据访问这个共享资源的线程数来决定的。逐步升级</span>


#### 偏向锁
> 适用于只有一个线程来访问这个对象的情况

- 线程第一次获取锁的时候，JVM会在对象头中记录该线程的 ID 
- 之后等该线程再次回去锁的时候，就不需要 CAS 的操作，直接判断是否是自己的线程 ID 就可以了，甚至可以免去了互斥锁的操作
- 如果有另一个线程尝试访问这个锁的时候，那么偏向锁就会撤销，转化为轻量级锁。


#### 轻量级锁

> 我们可以简单的理解为 乐观锁

**适用于多个线程竞争，但是没有真正的锁竞争**
锁存储来线程的栈中的 `Lock Record` 的结构中，并且使用 CAS 来尝试获取锁。

- 如果获取成功了，那么就进入临界区
- 如果失败了，那就继续的升级锁为重量级锁。


#### 自旋锁 
10次

#### 重量级锁


#### 总结
总的来说就是

1. 我们如果最理想的情况，始终只有单线程，而且都是一样的线程在访问某个资源的时候，我们就使用偏向锁

    这个时候，甚至省去了 **乐观锁** 的操作，直接就利用 `ID` 来判断是否为自己。

2. 我们进行升级，但是此时理论上依旧是单线程访问，只不过可能有多个线程来访问这个资源，但是不会发生并发冲突的情况。这种时候，我们就选择使用轻量级锁， `CAS` ，也就是乐观锁来进行保护即可。开销比较小。

3. 如果发生了锁冲突，此时我们就会选择使用自旋锁，也就让线程自旋进入等待，比如此时我们设置了 `num == 10`，来作为发生锁冲突的自旋次数上限。如果超过了这个次数，那么就会升级为重量级锁。

4. 重量级锁，其实也就是互斥锁，这种代价是最高的，但是也是最安全的。
