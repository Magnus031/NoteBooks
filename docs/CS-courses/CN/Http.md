# <center>HTTP协议</center>
> 鉴于这一章是 计算机网络中的高频考点，我这里专门列出 HTTP相关的知识进行整理，方便自己复习

## 基础知识
### 什么是 `SSL` / `TLS` 呢？
- `SSL`(Secure Sockets Layer) 安全套接层，是为网络通信提供安全及数据完整性的一种安全协议。它是在应用层和传输层之间的一种协议，用于在客户端和服务器之间建立一个安全的连接。`SSL` 协议的主要功能是保护网络通信的安全性，保证数据在传输过程中不被窃取或篡改。

- `TLS` (Transport Layer Security) 安全传输层协议，是`SSL`的**继任者**，它是一个安全协议，用于在客户端和服务器之间建立一个安全的连接。`TLS` 协议的主要功能是保护网络通信的安全性，保证数据在传输过程中不被窃取或篡改。

`SSL` 已经被弃用了。现在的安全协议都是基于 `TLS` 的。**值得注意的是，现在的浏览器都强制使用`TLS1.2`及以上的版本协议了**


### TLS 的握手过程
> `TLS shakehand` 是建立安全连接的过程，在握手的过程中会有以下的几种额外的操作:
>
> - 协商加密算法
> - 验证身份
> - 交换密钥


- 身份验证 (Authentication) : **服务器**向客户端证明自己的身份的真伪合法性
- 密钥交换 (Key Exchange) : **客户端**和**服务器**之间交换密钥，用于加密和解密数据
- 安全加密 (Secure Encryption) : **客户端**和**服务器**之间的通信是加密的，保证数据的安全性
- 数据完整性 (Data Integrity) : 保证数据在传输的过程中不被篡改

> 首先，我们要知道的是，现在的`HTTPS`协议已经放弃了`SSL`协议，转用了 `TLS` 协议作为安全协议。所以这里我们主要讲的是 `TLS` 的握手过程。后续也会出现一个 `SSL`证书的名词。


- Step1 : 首先是由客户端发起的 `Client Hello` 请求，包含了:

    - 支持的 TLS 版本 (TLS1.2/TLS1.3)
    - 支持的加密套件    
    - 支持的压缩算法
    - 一个随机数 (Client Random) 用于后续生成密钥

- Step2 : 服务端接收到客户端的请求的时候，会返回一个 `Server Hello`，包含了 :

    - 确定TLS版本 
    - 确定加密算法
    - 发送一个 SSL 证书（包含了服务器的公钥）
    - 发送一个随机数 (Server Random) 用于后续生成密钥


<span style = "color:red">补充</span>

**CA (Certificate Authority)**证书颁发机构，是一个可信的第三方机构，用于验证证书的真实性。证书由他颁发，管理，验证。用来验证网站、服务器、个人的身份合法性。



- Step3 : 服务器身份认证 （这一步是由客户端进行，客户端在接收到服务端的证书回复之后，要进行身份的校验:

    - 验证证书是否被可信的CA签发
    - 域名是否匹配
    - 证书是否过期

- Step4 : 客户端如果验证到服务器的身份合法。那么就会进入生成对称密钥对阶段 : 

    - 客户端生成一个 （Pre-Master Secret） 随机数
    - 用服务器在`SSL` 证书中包含的公钥加密这个随机数，然后发送给服务端
    - 服务器可以用私钥来进行解密这个随机数，得到相同的预主密钥。也就是说这个 (Pre-Master Secret) 是客户端和服务器之间共享的密钥
    - 这样客户端和服务端都用 CLient Random + Server Random + Pre-Master Secret 生成了一个 `Master Secret` 密钥,也就是 **对称密钥**


- Step5 : 客户端发送 `finished`

    - 客户端用新生成的 **对称密钥** 加密一个 **Finished** 消息给服务器
    - 服务器用相同的 **对称密钥** 解密这个消息，然后生成一个 **Finished** 消息，验证是否一致

- Step6 : 服务端发送 `finished` 

握手结束，客户端和服务端之间的通信就是加密的了。

> 非对称和对称的区别 就是加密和解密的时候是否用同一个密钥。非对称加密的时候，加密和解密的密钥是不一样的。对称加密的时候，加密和解密的密钥是一样的。

### 状态码

首先，我们知道的是 状态码其实就是 `x + y` 的形式，`x`表示的就是状态的类型，`y`表示的就是状态的具体信息。比如 `200` 表示的是成功，`404` 表示的是资源未找到。


- **1xx** : 信息性状态码，表示请求已经被接收，继续处理
- **2xx** : 成功状态码，表示请求已经被成功接收，理解，接受
- **3xx** : 重定向状态码，表示需要进一步的操作来完成请求
- **4xx** : 客户端错误状态码，表示请求包含语法错误或者无法完成请求
- **5xx** : 服务器错误状态码，表示服务器无法完成明显有效的请求

### HTTP的请求类型

- **GET** : 用于请求数据，请求的数据会附在 URL 后面
- **POST** : 用于提交数据，提交的数据会附在请求体中
- **PUT** : 用于更新数据，更新的数据会附在请求体中
- **DELETE** : 用于删除数据，删除的数据会附在请求体中
- **HEAD** : 用于获取报文首部，不会返回报文主体。类似于 GET 请求，不过只返回资源的头部信息，用于获取资源的元数据而不是资源本身。

#### Head 请求的使用场景

- 检查资源是否存在，而不是需要下载

    假设你需要验证 `https://example.com/file.pdf` 文件是否存在的时候，但是你不需要下载他们， 你就可以直接发送一个 `HEAD` 请求:

    ```java
    public class HeadRequestExample{
        String url = "https://example.com/file.pdf";

        try{
            HttpURLConnection connectioon = (HttpURLConnection) new URL(url).openConnection();
            // We set the request method to HEAD
            connection.setRequestMethod("HEAD");

            int responseCode = connection.getResponseCode();
            if(responseCode == HttpURLConnection.HTTP_OK){
                System.out.println("The file exists");
            else {
                System.out.println("The file does not exist");
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    ```

    其实这里是有点类似 `SQL` 语句中的 `SELECT COUNT(*)` 语句，只是用来检查资源是否存在，而不是需要下载。

- 获取资源元信息
    
    配合缓存机制，当客户端已经缓存了一个文件的时候，可以通过`HEAD`请求来获取资源的 `Last-Modified` 或者`Etag` 值，从而判断服务器是否已经更新，如果没有更新那么就不需要重新下载。
- 性能优化

    因为 `HEAD` 请求不包含请求体，所以它网络带宽使用效率会更高，特别适合在大文件或者高流量的情况下使用。






## 面试真题

### Q1 HTTP为什么不安全?

`HTTP(HyperText Transfer Protocol)` 超文本传输协议，它是明文传输的，缺乏了加密和身份验证机制。所以在传输的过程中可能会出现以下的几种情况:

- **窃听** : 因为是明文传输，它的内容都会暴露在网络上，所以有可能被窃听
- **篡改** : 传输过程中，有可能被篡改，比如在传输过程中，有人把你的请求或者响应给篡改了。就比如说强行的往内容中插入病毒广告
- **冒充** : 比如冒充淘宝网站 `https://www.taobao.com` 和 `http://www.taobao.com` 两个网站，这两个网站的内容是一样的，但是一个是假的，一个是真的。这样就会造成用户的信息泄露。

下面举了一个关于 `http` 容易被冒充的例子:

> 假设小明想访问淘宝，然后搜索了`http://www.taobao.com` 这个网址。由于是明文传输的，你发起的网络请求就会被截获，然后被篡改。这样就会造成用户的信息泄露。攻击者进行了 `DNS劫持`,把用户的请求指向了一个假设的淘宝网站，这样就会造成用户的信息泄露。 **这里其实可以比较好理解的为一种重定向(redirect)到了一个假的购物网站**，可以和淘宝很像，所以用户就会被骗。


### Q2 HTTPS 和 HTTP 的区别?

我们这里提一下 `HTTPS`，其实就是在 `HTTP` 协议的基础上加上了 `SSL` 或者 `TLS` 协议，也就是说在 `HTTP` 的基础上加上了加密和身份验证机制。这样就可以解决 `HTTP` 明文传输的问题。  

**第一点**，`HTTPS` 进行了相对应的保护

针对上述讲的三点，我们的`HTTPS`提供了相对应的保护 :

- 信息加密: 交互的信息无法被窃取，因为是进行秘文进行传输的
- 校验机制: 因为我们上面提到了可能会被恶意篡改内容，所以我们需要一个校验机制，来确保内容的完整性
- 身份验证: 通过证书的方式来验证服务器的身份，确保是真实的服务器，而不是冒充的。



**第二点**，二者的默认端口是不一样的 :

- `http` 的默认端口是 `80`
- `https` 的默认端口是 `443`


**第三点**，在传输的过程中，`HTTPS` 不仅仅需要`TCP`的三次握手，还需要`SSL`的握手，才能进入报文的加密阶段, 所以在建立连接的时候，会比`HTTP`慢一些。

**第四点** `HTTPS` 需要向 `CA` 机构申请证书，而且需要一定的费用，所以相对来说，`HTTPS` 的成本会比较高一些。



### Q3 请说一下 `HTTPS` 中得到的状态码 `502` 和 `504` 的含义?

首先， `502` 和 `504` 都是网关或者代理服务器的错误状态码，表示的是服务器作为网关或者代理，从上游服务器接收到一个无效的响应或者没有及时从上游服务器接收到请求。
 

- **502** : `Bad Gateway` 服务器作为网关或者代理，从上游服务器接收到一个无效的响应

- **504** : `Gateway Timeout` 服务器作为网关或者代理，但是没有及时从上游服务器接收到请求

### Q4 请说一下 `HTTPS` 中得到的状态码 `301` 和 `302` 的含义?

首先，`301` 和 `302` 都是重定向的状态码，表示的是请求的资源已经被移动到了新的位置，需要重新定位。

接下来就是二者的区别

- **301(Moved Permanently)** 其实是永久重定向的错误码.

    - 请求的资源 URL 被永久的移动到了新的位置
    - 客户端在将来应始终使用新的 URL 来访问资源
    - **浏览器会自动的将 URL 缓存下来，方便下一次的访问**
    - 【使用场景】：域名的变更

- **302(Found)** 临时重定向的错误码 和上面相对应的就是临时的。

    - 请求的资源被 **临时** 移动到了新的位置
    - 用户的下次请求还是访问原来的URL 
    - 【使用场景】： 
        - A/B 测试，根据流量不同进行重定向
        - 系统维护的时候，将用户重定向到维护页面

### Q5 请你说一下 `GET` 请求和 `POST` 请求之间的区别

#### 从语义行为上看

- `GET` 请求的语义 : 从服务器获取指定的资源

    这个资源是可以对静态的文件、页面、图片视频进行请求。而且`GET`请求的参数位置是放在 `URL` 后面的。但是浏览器会对 `URL` 的长度有限制，所以在传输的时候，会有一定的限制。
- `POST` 请求的语义 : 根据请求负荷(payload)对指定的资源进行处理

    从语义中就能知道，我们`POST`携带的数据是置于请求体`body`中的，这样就没有URL的长度限制。

#### 从幂等角度来看

> 这里的幂等性是指对于同一个请求，多次请求的结果是一样的。

- 线性代数中其实就有这样的概念。我们为什么 `GET`请求是幂等的呢？就是因为`GET`请求是 `Read-only`，并且我们可以将所请求到的数据放在`缓存`中。可以做到浏览器的本身上，也可以放在代理服务器`nginx`上。而且浏览器中的`GET`请求可以保存为书签

- 而`POST`请求就是对资源进行处理，所以是不安全的。而且多次提交数据会创建多个资源，所以是不幂等的。一般浏览器不会储存 `POST` 的数据，也不能把 `POST` 请求保存为书签。

-> 这里申引一下就是我们在浏览器中的 `local storage` 和`session storage` 其实就是在网站通过 `GET` 请求过后会把数据存储在本地的(前提是浏览器开启了缓存机制)。 


### Q6 你知道 HTTP报文的组成部分？

我们分成两类来看:

- `Request` 请求报文:

    - 请求头: 
        1. 请求的附带信息 
           1. Host
           2. User-Agent
           3. Content-Type
    - 请求行:
        1. 请求方法 GET POST PUT DELETE
        2. 请求目标 URL URI
        3. HTTP协议版本
    - 空行 : 请求头部和请求体之间需要用空行分割
    - 请求体 :
        1. PayLoad


- `Response` 响应报文:

    - 响应头部:
        1. 响应的附加信息:
            1. Content-Type
            2. Content-Length
    - 状态行:
        1. HTTP协议版本
        2. 状态码
        3. 状态信息

    - 空行: 响应头部和响应体之间需要用空行分割
    - 响应体:
        1. PayLoad
