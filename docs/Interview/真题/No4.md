# <center>第四套</center>
> 淘天后端实习


## 八股部分
### Q1 http 的工作流程

1. **DNS解析**：将域名解析为IP地址，客户端会先查看本地缓存，若无结果，就会向递归DNS服务器发送请求，最终获取对象的 IP 地址。

2. **TCP连接**：客户端与服务器建立TCP连接，三次握手。
3. **发送请求**：客户端向服务器发送请求，请求报文由请求行、请求头、空行、请求体四部分组成。
    
    - 请求行：包含请求方法、URL、HTTP协议版本。
    - 请求头：包含请求的头部信息，如User-Agent、Host、Connection等。
    - 空行：请求头和请求体之间的空行。
    - 请求体：请求的数据。(payload) 

4. **服务器处理请求** ： 服务器接收到请求后，会根据请求的 URL 路径，找到对应的处理程序，生成响应数据。
5. **客户端处理响应** ： 客户端接收到响应数据后，会根据响应头中的 Content-Type 字段来解析数据，然后渲染页面。
6. **断开连接** ： 客户端与服务器断开连接，四次挥手。

### Q2 讲一下 hash索引 和 B+Tree索引 的区别

我个人认为，在Hash索引和B+Tree索引的选择中其实是存在一种 trade-off 的，B+Tree 以时间复杂度的牺牲-- $O(\log(N))$些来换取范围查询的能力，但是 Hash 索引的优势就在于等值查找的速度极快$O(1)$。但是不方便进行范围查询。


### Q3 如果 sql 数据查询的速度很慢，那么你会怎么优化？
对于 sql 的优化，我认为有很多种方法。

1. 查看数据的查询是否使用了索引，如果没有使用索引，那么就需要对这个字段进行索引。如果索引的话，可以考虑一下这个索引是否能起到比较好的优化查询性能的作用。比如有些 类似 **性别** 这种字段进行设置索引就是没有意义的。

2. 我们优化 select 子句，尽量不要使用 `select *` 这种写法，尤其是在表中的有很多字段的时候，这样会造成查询的性能下降。

3. 我们使用 `Explain` 关键字来查询我们的索引情况，看看我们的查询是否使用了索引，以及索引的类型是什么。从而看一下是否需要对这个索引进行优化。

4. 引入外部的 Redis 缓存，来将一些查询到的数据存储到 Redis 中，从而减轻数据库的压力。

5. 优化表的结构，看一下是否可以拆成多个关联的小表，从而减轻查询整张大表的压力，但是相应的存储空间会增大。

6. 优化 sql 语句，看一下是否可以通过 sql 语句的优化来提高查询的性能。

7. 避免索引失效，也就是使用 `Like` 等模糊搜索的关键字的使用


### Q4 http 中的`Get` 方法和 `Post` 方法的区别。


- 从语义本质上看:
  
    首先，我们要知道的是 `Get` 方法的语义 就是表示从服务器获取资源的意思，它的本质是要保证幂等性，也就是每次的向服务器请求的结果都是一样的。

    但是`POST`方法的语义是向服务器提交数据，也就是说每次的请求都是不一样的，所以它是不保证幂等性的。它可以是从服务器获取资源，也可以是向服务器提交数据。也可以是修改服务器的资源。

- 从数据的传输来看：

    Get 方法会将 KV 请求对暴露在 URL 中，同时因为 URL 的长度是有限制的，所以 Get 方法传输的数据是有限制的。

    而 Post 方法是将数据放在请求体中，所以它的数据是不会暴露在 URL 中的，同时它的数据是没有限制的。而且可以传输的数据类型也是多样的。


### Q5 ConcurrentHashMap 的实现原理

其实`ConcurrentHashMap` 就是一个线程安全的`HashMap`,它的数据存储的机制和`HashMap` 是一样的，通过数组来模拟桶，在处理Hash冲突的时候，使用链表或者红黑树来解决冲突。当链表长度 > 8 并且数组长度大于64的时候，链表就会转换成红黑树。对于线程安全的并发处理，`ConcurrentHashMap`在 JDK 1.7及其以前的版本使用了分段锁的机制，也就是说将整个数组分成了很多个小的段，每个段都有自己的锁，这样就可以减小锁的粒度，提高并发的处理能力。但是在 JDK 1.8 之后，`ConcurrentHashMap` 使用了 `CAS` 和 `Synchronized` 来保证线程安全，这样就提高了并发的处理能力。也就是说利用了悲观锁和乐观锁同时使用各司其职的机制来保证线程安全。如果某个 `put` 操作发现没有冲突，就会选择使用 `CAS` 来进行操作，如果发现有冲突，就会使用 `Synchronized` 来进行操作。

### Q6 想问一下 Java 中的 `static volatile` 关键字使用的地方在哪里？

首先，我们要知道，`static` 表示的静态的，也就是这个资源只依赖于这个类，而不是某个实例。 `volatile` 的含义就是表示这个资源是多个线程共享的，某个线程对这个资源进行修改的时候，其他的线程都是可视的，也就是说其他的线程都能够看到这个资源的变化。所以很自然的就能发现 `static voilatile` 有以下的几种情况 : 

- 多线程的时候，作为共享资源，保证线程的可见性。
- 作为单例模式的时候，保证单例的唯一性。双重锁的机制来保证单例的创建的唯一性.


### Q7 谈一下 Java 的内存模型