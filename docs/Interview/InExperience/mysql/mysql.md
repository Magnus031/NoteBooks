# <center>DB</center>

## 数据库的分类
1. 关系型数据库

      - Mysql 
      - PostgreSQL 
      - Oracle 
      - SQLServer

2. 非关系型数据库 Nosql 
      -  Redis  
      -  MongoDB


## 数据库的特征
> 同时需要知道的是，对于关系数据库和非关系数据库的选择来说，如果强烈需要的是保证ACID的特性的，那么我们通常会选择关系型数据库，反之我们会选择非关系型数据库。

**ACID** 是数据库事务的四个特性，指的是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

下面以一个例子来进行阐述数据库事务的四个特性：

![P1](./assets/DB-p1.jpg)

### Atomicity 原子性

> 可以这样的理解，我们把一次事务看成是现实世界中的一次 **状态切换** 

原子性，也就是字面意思，要求的是让某个单位事务中的多个子操作都看成一个整体，要么都成功，要么都失败。

假设 上面图中的用户A 要给用户B 转账 `10` r。那么就会经历下面这个过程:

![P2](./assets/DB-p2.jpg)

我们需要保证的是，这个事务是一整个完成的，也就是说 既有前者扣款成功，又有后者的到账。否则的话就会出现中途丢失的状况，这并不算一个事务的完成。

当然我们现在也只是在逻辑的层面进行，其实具体到数据库的实现细节，可能还有`buffer pool` 中的一些实现细节，比如先修改到缓存页，再写入磁盘，抑或是有关脏页的写与读等等，是一系列的操作。

### Isolation 隔离性
> 隔离性的字面意思就是隔离，也就是说在一个事务中的操作不会影响到其他事务的操作。

每个事务之间是独立的，同时事务与事务之间不会影响到其他事务的操作。
简单的例子，我们想让刚刚的一次性转账10r分成了两次进行操作，每次都只转5r，那么就产生了两个事务。

![P3](./assets/DB-p3.jpg)

但事实上，以上的操作其实并不是这样的那么简单的单个进行完才会轮到下一个进行的。如果是这样的话，效率太低了，事实上是很多操作可能会并发的进行。就像体系结构的流水线中的乱序一样，很多指令的原单位操作会有乱序的并入，而我们的隔离性要保证的是，就算是乱序的并入，也要保证最终结果的正确。

我们看下面这个例子，就会发现这样的一个问题，如果我们的隔离性不够好，那么就会出现这样的一个问题，就是我们的事务之间会相互影响。本来A应该只剩下了1r，因为进行了两次的转账，但是A的钱变成了6r。有一次转账的操作，但是A少扣钱了。这个就是一次比较失败的隔离。
![P4](./assets/DB-p4.jpg)

#### 不考虑隔离性的情况，会出现的问题

-  **脏读(Dirty Read)**：一个事务读取到了另一个事务未提交的数据

比如事务A读到了一个数据库中的数据，但是由于某种原因，事务B回滚了，导致事务A读到了一个不正确的数据。

-  **不可重复读(Nonrepeated Read)**：一个事务读取到了另一个事务已经提交的数据

一个简单的例子，比如事务A读取了一个数据，然后事务B修改了这个数据，然后事务A再次读取这个数据，发现数据已经发生了变化。

-  **幻读(Phantom Read)**：一个事务读取到了另一个事务插入的数据

事务A对表中的所有行的某个数据进行了修改操作，但是此时事务B的某项操作，导致又插入了一行数据，这个时候事务A再次读取这个表，发现多了一行数据。或者是发现又回到了自己更改之前的情况，这个就是幻读。

> 前者和后面两者的区别是 whether the data is commited. 前者脏读只是读取了未提交的数据，但是后者是读取了已经提交的数据。



### Consistency 一致性
这里的一致性其实就是指的是，我们数据库中的数据要和现实世界的数据约束是一致的。**(All defined rule)** 一个最简单的例子就是银行账户的`balance` 不能为负数。    

Mysql 在保证一致性的时候，可以做出以下努力：

1. 在建立表的时候，就规定如 `NOT NULL` 这样的量词限定
2. 我们可以添加 `Check` 语法来自定义约束
   ```sql
   CREATE TABLE account (
    id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
    name VARCHAR(100) COMMENT '客户名称',
    balance INT COMMENT '余额',
    PRIMARY KEY (id),
    CHECK (balance >= 0) 
    );
   ```
但这里有个不足的地方就是，虽然我们以 `Check` 子句来限定了`account`表，但是在后续插入或者更新记录的时候，就不会去检查这个约束了。这个时候就需要我们自己来进行检查了。

3. 我们可以定义触发器来进行约束条件的检查，来保证一致性。
   ```sql
   CREATE TRIGGER check_balance
   BEFORE INSERT ON account
   FOR EACH ROW
   BEGIN
    IF NEW.balance < 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'balance must be >= 0';
    END IF;
   END;
   ```

可以这么说，**原子性**和**隔离性**都是保证**一致性**的一个手段。




### Durability 持久性
> 字面意思就是持久性，也就是说一旦事务完成，那么它的结果就是永久的。
> 

不会因为系统的崩溃而丢失。该事务的转换数据库操作所修改的数据会在磁盘上保留下来，无论发生了什么事故，本次转换的结果都不会丢失。以便后续的undo和redo操作。








## 数据库的三大范式
### 第一范式 1NF
> 要保证每一列的原子性，也就是说每一列的值都是不可再分的。





## 真题
### 1. 什么是数据库的隔离级别?
> 这题要在理解过 AICD 之后再回来看会比较好理解

数据库的隔离级别就是指的是数据库事务的隔离程度，也就是说在一个事务中的操作对于其他事务的影响程度。上面的笔记中提及了有关事务如果没有隔离性会发生的问题，现在我们就利用四种隔离级别来解决问题。

#### Read Uncommitted 未提交读

![P5](./assets/DB-p5.jpg)


#### Read Committed 读提交

![P6](./assets/DB-p6.jpg)

#### Repeatable Read 可重复读

![P7](./assets/DB-p7.jpg)

#### Serializable 序列化

![P8](./assets/DB-p8.jpg)





<style>
img{
    display : block;
    margin-left : auto;
    margin-right : auto;
    width : 85%;
    border-radius : 15px;
}
</style>


